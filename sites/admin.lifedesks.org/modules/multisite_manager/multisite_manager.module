<?php
// $Id: multisite_manager.module,v 1.8.4.2 2008/03/12 19:10:34 schuyler1d Exp $

/**
 * Implementation of hook_perm().
 */
function multisite_manager_perm() {
  return array('create drupal site', 'delete own drupal site', 'advanced database setup', 'administer multisite defaults');
}

/**
 * author: Schuyler Duveen
 * sponsor: Columbia Univeristy Center for New Media Teaching & Learning
 * URL: http://drupal.org/project/multisite_manager
 * License: GPL v2 or any later version
 *
 * TODO
 * ----
 * test postgres
 * actual 'management' options?
 * update.php support
 * document settings.php setup
 * configuration to run as different DB user when creating DB and granting privileges
 * hook_before_site_install($node);
 * hook_after_site_install($node);
 */

/**
 * Implementation of hook_help()
 */
function multisite_manager_help($section) {
  switch ($section) {
    case 'admin/help#multisite_manager':
      return t('Multisite Manager helps create new drupal sites from within a main drupal site.  For documentation see <a href="http://drupal.org/project/multisite_manager">http://drupal.org/project/multisite_manager</a>.<p>This module is <b>NOT Plug-n-Play</b>. Before this module will work as desired follow these steps:<ol><li>Configure the Multisite Manager defaults for where new sites will be added to the database.</li><li>Make a special settings.php file in the /sites/ drupal directory. (This '. l( 'tool','admin/settings/multisite_manager/phpsettingfile') . ' will help)</li><li>Change your Apache config, probably in your Drupal .htaccess file.</li><li>For the default setup you need a symlink in your main Drupal directory.  After changing to that directory, run <code>$ ln -s . site</code></li><li>Lastly, the DB account that runs the main site must have extra DB permissions to create databases and grant privileges</li></ol></p>');
    case 'admin/settings/multisite_manager':
      return t('These defaults will need corresponding changes in settings.php.  Consult help for other required changes on the file system.');

  }
}


function multisite_manager_node_info() {
  return array(
    'drupal_site' => array(
      'name' => t('LifeDesk'),
      'module' => 'multisite_manager',
      'description' => t("This is a simple and quick method for creating a new LifeDesk."),
    )
  );
}

/**
 * Implementation of hook_cron()
 */
function multisite_manager_cron() {
  if(module_exists('drupal_sites')) {
    db_query("DELETE FROM {request_experts} WHERE status=2 AND created <= %d", time()-86400);
  }
}

/**
 * Implementation of hook_view().
 */
function multisite_manager_view($node, $teaser = FALSE, $page = FALSE) {
  global $base_url;
  $node = node_prepare($node, $teaser);
  if ($node->installed) {
    if ($node->link) {
      $node = _multisite_manager_node_url($node);

      //header('Location: '. $url);
      $node->content['link'] = array(
       '#value' => theme('multisite_manager_sitelink', $node),
       '#weight' => 1,
       );
    }
  } else {
    $node->content['installed'] = array(
      '#value' => t("This Drupal site will be created on the next batch creation."),
      '#weight' => 1,
    );
  }
  return $node;
}

/**
 * Implementation of hook_menu().
 */
function multisite_manager_menu() {
  $items = array();
  $items['admin/settings/multisite_manager'] = array(
    'title' => t('Multisite Manager settings'),
    'description' => t('Configure the database and url defaults for new sites.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('multisite_manager_admin_settings'),
    'access arguments' => array('administer multisite defaults'),
    'file' => 'multisite_manager.admin.inc',
    );
  $items['admin/settings/multisite_manager/defaults'] = array(
    'title' => t('Defaults'),
    'description' => t('Configure the database and url defaults for new sites.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('multisite_manager_admin_settings'),
    'access arguments' => array('administer multisite defaults'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'multisite_manager.admin.inc',
    );
  $items['admin/settings/multisite_manager/phpsettingfile'] = array(
    'title' => t('settings.php help'),
    'type' => MENU_LOCAL_TASK,
    'description' => t('What to put in the settings.php file'),
    'page callback' => 'multisite_manager_admin_file_settingsdotphp',
    'access arguments' => array('administer multisite defaults'),
    'file' => 'multisite_manager.admin.inc',
    );
  $items['check_sitename'] = array(
    'title' => t('Multisite Manager Shortname Check'),
    'page callback' => 'multisite_manager_check_shortname',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
    'file' => 'multisite_manager.admin.inc',
    );
  return $items;
}

/**
 * Implementation of hook_access().
 */
function multisite_manager_access($op, $node) {
  global $user;

  if ($op == 'create') {
    // Only users with permission to do so may create this node type.
    return user_access('create drupal site');
  }
  // Users who create a node may edit or delete it later, assuming they have the  // necessary permissions.
  if ($op == 'update' || $op == 'delete') {
    if (user_access('delete own drupal site') && ($user->uid == $node->uid)) {
      return TRUE;
    }
  }

}

function _multisite_manager_defaults() {
  /*
  global $db_url, $db_prefix;
  $url = parse_url(is_array($db_url) ? $db_url['default'] : $db_url);
  $db_user = urldecode($url['user']);
  $db_pass = urldecode($url['pass']);
  $db_path = ltrim(urldecode($url['path']), '/');
  */
  return array('profile' => variable_get('multisite_manager_profile_default', 'default'),
	       'db_prefix' => variable_get('multisite_manager_dbprefix_default', '{shortname}_'),
	       'db_user' => '',
	       'db_pass' => '',
	       'db_path' => variable_get('multisite_manager_dbpath_default', ''),
	       'link' => variable_get('multisite_manager_link_default', ''),
	       'run_cron' => variable_get('multisite_manager_run_cron', 0),
	       );
}

function _multisite_manager_profile_options() {
  $profiles = file_scan_directory('./profiles', '\.profile$', array('.', '..', 'CVS'), 0, TRUE, 'name', 0);
  $profile_options = array();
  foreach ($profiles as $profile) {
    require_once $profile->filename;
    $function = $profile->name.'_profile_details';
    $details = $function();
    $profile_options[$profile->name] = $details['name'].': '.$details['description'];
  }
  return $profile_options;
}

/**
 * Implementation of hook_form().
 */
function multisite_manager_form(&$node) {
  include_once './includes/install.inc';

  $type = node_get_types('type', $node);

  $defaults = _multisite_manager_defaults();

  if (module_exists('drupal_sites')) {
    $title = $_REQUEST['title'];
    $shortname = $_REQUEST['shortname'];
    $givenname = $_REQUEST['givenname'];
    $surname = $_REQUEST['surname'];
    $email = $_REQUEST['email'];
    $username = $_REQUEST['username'];
	$password = $_REQUEST['password'];
	$md5 = $_REQUEST['md5'];
  }
  $form['multisite_manager'] = array(
    '#weight' => -10,
  );
  $form['multisite_manager']['multisite_manager_message'] = array(
    '#type' => 'markup',
    '#value' => '<div id="multisite_manager_message"></div>',
	'#weight' => -10,
  );
  $form['multisite_manager']['title'] = array(
    '#type' => 'textfield',
    '#title' => check_plain($type->title_label),
    '#required' => TRUE,
    '#default_value' => isset($title)?$title:$node->title,
    '#weight' => -5
  );
  $form['multisite_manager']['run_cron'] = array(
    '#type' => 'checkbox',
    '#title' => t('Run Drupal Sites\' Cron'),
    '#required' => FALSE,
    '#default_value' => isset($node->run_cron)?$node->run_cron:$defaults['run_cron'],
    '#description' => t('This sets whether this drupal site\'s cron jobs will be run when the master site\'s cron is run and is configured to trigger sites.  By default, it is set ON only if the master is configured to trigger sites.'),
    );
  $form['multisite_manager']['shortname'] = array(
    '#required' => TRUE,
    '#type' => 'textfield',
    '#title' => t('Shortname'),
    '#default_value' => isset($shortname)?$shortname:$node->shortname,
    '#size' => 15,
    '#maxlength' => 45,
    '#description' => t('This short name will be used in the database as a unique identifier and also possibly the default site location.  This must only be numbers and letters'),
    '#weight' => -4,
	'#ahah' => array(
	  'event' => 'blur',
	  'path' => 'check_sitename',
	  'wrapper' => 'multisite_manager_message',
	  'progress' => 'none',
    ),
  );
  $form['multisite_manager']['givenname'] = array('#type' => 'textfield',
    '#title' => t('Given Name'),
    '#default_value' => isset($givenname)?$givenname:$node->givenname,
    '#size' => 60,
    '#required' => TRUE,
    '#description' => t('Please enter Given Name of new LifeDesk Owner'),
    '#weight' => -3
  );
  $form['multisite_manager']['surname'] = array('#type' => 'textfield',
    '#title' => t('Last Name'),
    '#default_value' => isset($surname)?$surname:$node->surname,
    '#size' => 60,
    '#required' => TRUE,
    '#description' => t('Please enter Last Name of new LifeDesk Owner'),
    '#weight' => -3
  );
  $form['multisite_manager']['mail'] = array('#type' => 'textfield',
    '#title' => t('E-mail address of new LifeDesk Owner'),
    '#default_value' => isset($email)?$email:$node->mail,
    '#size' => 60,
    '#required' => TRUE,
    '#weight' => -2
  );
  $form['multisite_manager']['username'] = array('#type' => 'hidden',
    '#title' => t('Username'),
    '#default_value' => $username,
  );
  $form['multisite_manager']['password'] = array('#type' => 'hidden',
    '#title' => t('Password'),
    '#default_value' => $password,
  );
  $form['multisite_manager']['md5'] = array('#type' => 'hidden',
    '#title' => t('md5'),
    '#default_value' => $md5,
  );
  $form['multisite_manager']['profile'] = array(
    '#type' => 'radios',
    '#title' => t('Profile'),
    '#required' => TRUE,
    '#options' => _multisite_manager_profile_options(),//array_combine($profiles,$profiles),
    '#default_value' => isset($node->profile)?$node->profile:$defaults['profile'],
    '#weight' => -1
  );
  $form['multisite_manager']['advanced'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#access' =>user_access('advanced database setup'),
    '#description' => t('Once created, modifying these values will not do anything except change the local record.  If you need to move the database around, you must do it yourself through the database.  Then update the record here.'),
  );
   $form['multisite_manager']['advanced']['link'] = array(
    '#type' => 'textfield',
    '#title' => t('Site Link'),
    '#default_value' => isset($node->link)?$node->link:$defaults['link'],
    '#required' => FALSE,
    '#access' =>user_access('advanced database setup'),
    );
   $form['multisite_manager']['advanced']['db_prefix'] = array(
    '#type' => 'textfield',
    '#title' => t('Table prefix'),
    '#default_value' => isset($node->db_prefix)?$node->db_prefix:$defaults['db_prefix'],
    '#required' => FALSE,
    '#access' =>user_access('advanced database setup'),
    );
   $form['multisite_manager']['advanced']['db_user'] = array(
    '#type' => 'textfield',
    '#title' => t('Database username'),
    '#default_value' => isset($node->db_user)?$node->db_user:$defaults['db_user'],
    '#required' => FALSE,
    '#access' =>user_access('advanced database setup'),
    '#description' => t('Do NOT set this unless your current database account has GRANT option in MySQL or CREATEUSER in Postgres.'),
    );
   $form['multisite_manager']['advanced']['db_pass'] = array(
    '#type' => 'password',
    '#title' => t('Database password'),
    '#default_value' => $defaults['db_pass'],
    '#required' => FALSE,
    '#access' =>user_access('advanced database setup'),
    );
   $form['multisite_manager']['advanced']['db_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Database name'),
    '#size' => 45,
    '#maxlength' => 45,
    '#default_value' => isset($node->db_path)?$node->db_path:$defaults['db_path'],
    '#required' => FALSE,
    '#access' =>user_access('advanced database setup'),
    '#description' => t('Do NOT set this unless your current database account has CREATE option in MySQL or CREATEDB in Postgres.  To ensure database data is not overwritten, if you install in another database, it is either required that your current database have some db_prefix OR that it will be a new database--i.e. that your entry here includes "{shortname}".  (An error will result otherwise)'),
    );
   // yes, use {pound}access
   //is there a better way so only people with access can set these items?
   /*
   if (!user_access('advanced database setup')) {
     $form['multisite_manager']['advanced']['db_prefix']['#value'] = $defaults['db_prefix'];
     $form['multisite_manager']['advanced']['db_user']['#value'] = $defaults['db_user'];
     $form['multisite_manager']['advanced']['db_pass']['#value'] = $defaults['db_pass'];
     $form['multisite_manager']['advanced']['db_path']['#value'] = $defaults['db_path'];
     $form['multisite_manager']['advanced']['link']['#value'] = $defaults['link'];

     $form['multisite_manager']['advanced']['db_prefix']['#type'] = 'hidden';
     $form['multisite_manager']['advanced']['db_user']['#type'] = 'hidden';
     $form['multisite_manager']['advanced']['db_pass']['#type'] = 'hidden';
     $form['multisite_manager']['advanced']['db_path']['#type'] = 'hidden';
     $form['multisite_manager']['advanced']['link']['#type'] = 'hidden';
   }
   */

  return $form;
}

/**
 * Implementation of hook_validate().
 */
function multisite_manager_validate(&$node) {
  global $locale, $multisite_manager_installmodules;
  include_once './includes/install.inc';
  $path = drupal_get_path('module', 'multisite_manager') . '/';
  include_once $path.'multisite_manager.admin.inc';

  if (!preg_match('/^[a-z]+$/', $node->shortname)) {
    form_set_error('shortname', t('The shortname you have entered, %shortname, is invalid. The shortname can only contain lowercase letters.', array('%shortname' => $node->shortname)), 'error');
  }

  if (!$node->nid) {//expected to be NULL if a new node
    ///if new drupal site, we check to see if the site is already entered
    ///we don't do this on updates, because maybe the DB admin moved the site manually and is just updating the record

    $already_exists = db_result(@db_query("SELECT shortname FROM {drupal_site} WHERE shortname = '%s' AND profile = '%s'",$node->shortname, $node->profile));
    if ($already_exists) {
      form_set_error('shortname', t('The shortname you have entered, %shortname, is already taken. Please use a different one.', array('%shortname' => $node->shortname)), 'error');
    }
    if (_multisite_manager_dbexists($node)) {
      form_set_error('shortname', t('The database location the site would be installed already exists. Please use a different shortname or database path and prefix.'), 'error');
    }

	global $mysql_reserve_words;
	foreach($mysql_reserve_words as $reserve_word) {
      if(strtoupper($node->shortname) == $reserve_word) {
        form_set_error('shortname', t('You are not authorised to create a LifeDesk with the shortname %shortname', array('%shortname' => $node->shortname)), 'error');
	  }
	}
  }

  /* Validating the email address - Start */
  if(!multisite_manager_valid_email($node->mail)) {
  //if ($error = user_validate_mail($node->mail)) {
    form_set_error('mail', 'Please enter a valid email address!');
  }
  /* Validating the email address - End */

  $multisite_manager_installmodules = drupal_verify_profile($node->profile, $locale);
  if (!$multisite_manager_installmodules) {
    form_set_error('profile', t('One or more required modules are missing!'), 'error');
  }

  if (!user_access('advanced database setup')) {
    /* With #access working in hook_form this should never be called */
    $defaults = _multisite_manager_defaults();
    if ($node->db_prefix != $defaults['db_prefix']
	|| $node->db_user != $defaults['db_user']
	|| $node->db_pass != $defaults['db_pass']
	|| $node->db_path != $defaults['db_path']
	|| $node->link != $defaults['link']
	) {
    form_set_error('shortname', t('Just use shortname.  You do not have access to modify the database settings directly.  If this is necessary, please contact your Drupal site administrator.'), 'error');
    }
  }
}

function multisite_manager_valid_email($str) {
  return ( ! preg_match("/^([a-z0-9\+_\-]+)(\.[a-z0-9\+_\-]+)*@([a-z0-9\-]+\.)+[a-z]{2,6}$/ix", $str)) ? FALSE : TRUE;
}

function install_no_profile_error() {
  //this function is required by drupal_verify_profile()
  //It should probably do something smarter here.
  echo t("Error installing profile!!!!!!");
}

function _multisite_manager_unparse_dburl($db) {
  //no such thing as query strings or fragments in db urls, right?
  $db_url = $db['scheme'].'://';
  if ($db['user']) {
    $db_url .= $db['user'];
    if ($db['pass']) {
      $db_url .= ':'.$db['pass'];
    }
    $db_url .= '@';
  }
  $db_url .= $db['host'];
  if ($db['port']) {
    $db_url .= ':'.$db['port'];
  }
  $db_url .= '/'.$db['path'];
  //ignoring any querystring or fragment
  return $db_url;
}

/*
 * Returns an associative array for the $node that
 * _multisite_manager_unparse_dburl() can turn into a database url
 * or be passed to _multisite_manager_dbswitch()
 */
function _multisite_manager_dbobj($node) {
  global $db_url;
  $cur_db = parse_url(is_array($db_url) ? $db_url['default'] : $db_url);

  if (strpos($cur_db['path'],'/')===0) {
    $cur_db['path'] = substr($cur_db['path'],1);
  }

  $new_db = $cur_db; //copying array, not reference

  //used for set_active array
  $new_db['name'] = 'multisite_manager_newdb';
  $new_db['prefix'] = str_replace('{shortname}', $node->shortname, $node->db_prefix);

  if ($node->db_user) {
    $new_db['user'] = str_replace('{shortname}', $node->shortname, $node->db_user);
  }
  if ($node->db_pass) {
    $new_db['pass'] = $node->db_pass;
  }

  if ($node->db_path && $node->db_path != $cur_db['path']) {
    //DIFFERENT DATABASE
    $new_db['path'] = str_replace('{shortname}', $node->shortname, $node->db_path);
    $new_db['new'] = TRUE;
  }
  else {
    $new_db['new'] = FALSE;
  }

  $new_db['url'] = _multisite_manager_unparse_dburl($new_db);
  return $new_db;
}

/* switch the db, but NOT the prefix!!!
 *
 */

function _multisite_manager_dbswitch($new_db) {
  global $db_url, $db_prefix;

  $cur_db = array('name' => 'default', //just a guess
		  'url' => $db_url,
		  'prefix' => $db_prefix,
		  );

  /* SWITCH TO NEW DB */
  if ($db_url != $new_db['url']) {
    if (!is_array($db_url)) {
      //this is hacking any just-a-string db_url into an array
      $db_url = array('default' => $db_url);
    }
    else {
      $cur_db['url'] = $db_url['default'];
    }

    $db_url[$new_db['name']] = $new_db['url'];

    //actually switch database. db_set_active() defined in includes/database.inc
    $cur_db['name'] = db_set_active($new_db['name']);
  }
  ///We no longer switch the prefix, because we rename the tables after the db is created
  ///any context that needs to switch the prefix should do so, itself, and when timely
  //$db_prefix = $new_db['prefix'];

  return $cur_db;
}

/*
 * Until this is in the db_* api..., return the error text from the last database query
 */
function _multisite_manager_db_error_message() {

  switch ($GLOBALS['db_type']) {
    case 'mysql':
      return mysql_error();
    case 'mysqli':
      global $active_db;
      return mysqli_error($active_db);
    case 'pgsql':
      return pg_last_error();
  }
}

/*
 * Returns true if the database exists where $node is directed
 */
function _multisite_manager_dbexists($node) {
  global $db_prefix;
  $new_db = _multisite_manager_dbobj($node);

  $already_exists = FALSE;
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $already_exists = db_result(@db_query("SHOW DATABASES LIKE '%s'", $new_db['path']));
      if ($already_exists) {
	$already_exists = db_result(@db_query("SHOW TABLES FROM %s LIKE '%s%%'", $new_db['path'], str_replace('_','\_',$new_db['prefix'])));
	if (!$already_exists && $db_prefix != $new_db['prefix']) {
	  ///to avoid watchdog set_active_db() problems we install on the current prefix and then rename tables to the new one
	  ///this needs to be doable, so we can't have tables hanging around that match the current prefix either
	  ///even (or especially!!!) if db_prefix == ''
	  $already_exists = db_result(@db_query("SHOW TABLES FROM %s LIKE '%s%%'", $new_db['path'], str_replace('_','\_',$new_db['prefix'])));
	}
      }
      break;
    case 'pgsql':
      ///Since we can't query tables in other DBs in postgres, we have to be a little more picky
      ///If the database is used by something else, but the prefix is safe, it's still a problem
      if (strpos($node->db_path,'{shortname}') !== FALSE) {
	$already_exists = db_result(@db_query("SELECT datname FROM pg_database WHERE datname = '%s'",$new_db['path']));
      }
      elseif (!$new_db['new']) {
	$already_exists = db_result(db_query("SELECT relname FROM pg_stat_user_tables WHERE relname LIKE '%s%%'", str_replace('_','\_',$new_db['prefix'])));
      }
      break;
  }
  return $already_exists;
}

/*
 * Creates a new database with permissions to the user if necessary.
 * (as deemed necessary by $new_db['new'] )
 */
function _multisite_manager_newdb($new_db) {
  if ($new_db['new']) {
    //DIFFERENT DATABASE
    ///create database
    ///if it already exists, then some error will return, but who cares?
    ///Actually, we DO care, because if it creates a new db here, we'll
    ///  delete it on node deletion
    ///in MYSQL you need the 'CREATE' privilege.
    ///in POSTGRES you need the 'CREATEDB' privilege
    #$create_req = 'CREATE DATABASE ';
    #if (strpos($GLOBALS['db_type'], 'mysql') !== FALSE) {
      #$create_req .= 'IF NOT EXISTS ';
    #}
    @db_query('CREATE DATABASE %s', $new_db['path']);
    $errors = db_error();

    if ($errors === 1007) {
      ///This is ok, maybe we put all the new databases in one other db
      drupal_set_message("Database already exists");
    }
    elseif ($errors) {
      //what's 1004: access denied!
      //needs GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES  on *.* to 'drupaluser'@'localhost' identified by '*****' with grant option;
      drupal_set_message("Database error when creating database: $errors", 'error');
      return FALSE;
    }
    elseif (!$errors) {
      // for creation of required folders & modifying permissions on them for each site to store uploaded files, pictures etc.
      mkdir(getcwd()."/files/".$new_db['path']);
      chmod(getcwd()."/files/".$new_db['path'], 0777);
      mkdir(getcwd()."/files/".$new_db['path']."/pictures");
      chmod(getcwd()."/files/".$new_db['path']."/pictures", 0777);
    }
  }
  /**
   * I was tempted to change user only if there's a new database
   * but clearly this account may have too many rights for a
   * sub-site, so there is a use case where db_user would change
   * without the db changing.
   */

  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      //do if new user AND new db
      if ($new_db['user'] != $cur_db['user'] && $new_db['new']) {
	//current user needs GRANT OPTION privilege
        @db_query("
          GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX,
                ALTER, CREATE TEMPORARY TABLES, LOCK TABLES
                ON %s.*
                TO '%s'@'%s' IDENTIFIED BY '%s'
          ", $new_db['path'], $new_db['user'], $new_db['host'], $new_db['pass']);
      }
      break;
    case 'pgsql':
      if ($new_db['user'] != $cur_db['user']) {//only if diff user
	//current user needs CREATEUSER privilege
        @db_query("
          CREATE USER %s ".
	  ($new_db['pass'])?" WITH PASSWORD '%s'":"%s".
        " NOCREATEDB
          NOCREATEUSER
        ", $new_db['user'], $new_db['pass']);
      }
      break;
  }
  $errors = db_error();
  if ($errors) {
    drupal_set_message(str_replace($new_db['pass'], '******', _multisite_manager_db_error_message()),'error');
  }
}

/**
 * Implementation of hook_insert().
 */
function multisite_manager_insert($node) {

  $install_immediately = variable_get('multisite_manager_install_immediate', TRUE);
  //Store some info about the new site in the main site.
  //Note that we DO NOT store the password
  db_query("INSERT INTO {drupal_site} (vid, nid, shortname,  profile, link, installed, run_cron, db_prefix, db_user, db_path, mail, givenname, surname) VALUES (%d, %d, '%s', '%s', '%s', %d, %d, '%s', '%s', '%s', '%s', '%s', '%s')", $node->vid, $node->nid, $node->shortname, $node->profile, $node->link, $install_immediately, $node->run_cron, $node->db_prefix, $node->db_user, $node->db_path, $node->mail, $node->givenname, $node->surname);
  if (module_exists('drupal_sites')) {
    db_query("UPDATE {request_experts} SET status=1 WHERE md5='%s'", $node->md5);
  }

  if ($install_immediately) {
    multisite_manager_install_site($node);
  }

  $database = $node->shortname;

  $created = db_result(@db_query("SHOW DATABASES LIKE '%s'", $database));

  if (module_exists('drupal_sites') && $created) {
    db_query("UPDATE {request_experts} SET status=2 WHERE md5='%s'", $node->md5);
  }

}

function multisite_manager_install_site($node) {
  /**
   *
   *  1. If it's a different database and/or user from the current
   *     then creates them (assumes db access to do so)
   *  2. switches to the new context (db,user,table prefix)
   *  3. installs drupal profile in new place
   *  4. switches back to current context
   */
  global $multisite_manager_installmodules, $db_prefix, $conf, $locale, $user;

  if (!$multisite_manager_installmodules) {
    ///if this function is run by a script, then _validate() won't have
    /// been called
    $multisite_manager_installmodules = drupal_verify_profile($node->profile, $locale);
    if (!$multisite_manager_installmodules) {
      echo "\n" . t("One or more required modules are missing!") . "\n";
      exit();
    }
  }

  //learn if there is an existing message on all sites such that newly created sites won't slip through the cracks
  $site_message = variable_get('lifedesk_announcements','');
  $site_version = variable_get('lifedesk_version', 'x');

  $from = variable_get('site_mail', 'lifedesk@eol.org');
  ///get user for admin account
  $current_user = $user->givenname;

  $admin_how = variable_get('multisite_manager_admin_account', 'copy admin');
  switch($admin_how) {
    case 'copy admin':
      $account = user_load(1);
      break;
    case 'copy creator':
      $account = $user;
  }

  #$multisite_manager_installmodules = drupal_verify_profile($node->profile, $locale);
  include_once './includes/install.inc';
  //

  /**
   * creates database and user w/ permissions if necessary
   * _newdb returns the db_url for the new site based on
   * the $node's arguments.
   *
   * The simplest case would be returning the same url as
   * the current one
   */

  $new_db =_multisite_manager_dbobj($node);
  _multisite_manager_newdb($new_db);

  /* SWITCH TO NEW DB */
  ///prefix is not changed here
  $cur_db = _multisite_manager_dbswitch($new_db);
  if (!$new_db['new']) {
    ///Only change the prefix if we're in the same database
    ///Otherwise, we will rename the tables AFTER creation.
    ///This stops watchdog() from switching back and not finding tables with the right prefix mid-installation
    $db_prefix = $new_db['prefix'];
  }
  /* DB QUERIES NOW ON NEW SITE DB */

  ///Store current $conf (all variable_get/set()'s)
  $cur_conf = $conf; //should be an array copy here
  $conf = array();

  ///THEFT (install.php)
  drupal_install_system();
  #variable_set('install_profile_modules', array_diff($multisite_manager_installmodules, array('system')));

  #install_tasks($node->profile, $task); //can't use this

  ///THEFT (install.php)
  $excluded_modules = preg_split("/[\s\n,;]+/",variable_get('multisite_manager_excluded_modules',''));
  $diff = array_merge(array_diff($multisite_manager_installmodules, $excluded_modules));
  drupal_install_modules($diff);

  /*BEGIN THEFT*/
  //TODO: install locale stuff
  /*END THEFT (install.php) */
  if($node->password) {
    $newusername = $node->name;
    $encrypted_pass = $node->password;
  } else {
    $newusername = 'Administrator';
    $newpass = user_password();
    $encrypted_pass = md5($newpass);
  }
  //$newpass = $node->password ? $node->password : user_password();
  $username = $node->username ? $node->username : 'Administrator';

  ///TASK 'configure' (superadmin and owner account)
  $ret = array();
  $timestamp = time();
  switch ($admin_how) {
    case 'do nothing':
      break;
    case 'copy admin':
      //change username of creator if matches username of superadmin account
      if($username == $account->name) {
        $username = 'administrator';
      }
      $ret[] = db_query("UPDATE {users} SET name = '%s', givenname = '%s', surname = '%s', pass = '%s', mail = '%s', status = 1 WHERE uid = 1", $account->name, $account->givenname, $account->surname, $account->pass, $account->mail);
      $ret[] = db_query("INSERT INTO {users} (name, givenname, surname, pass, mail, created, status) VALUES ('%s', '%s', '%s', '%s', '%s', %d, 1)", $username, $node->givenname, $node->surname, $encrypted_pass, $node->mail, $timestamp);
      break;
    case 'copy creator':
      $ret[] = db_query("UPDATE {users} SET name = '%s', givenname = '%s', surname = '%s', pass = '%s', mail = '%s', status = 1 WHERE uid = 1", $username, $node->givenname, $node->surname, $encrypted_pass, $node->mail);
      break;
  }
  //get site creator (owner) uid
  $owner_uid = db_result(db_query("SELECT uid FROM users WHERE name = '%s'", $username));
  // SET variable 'site_owner_uid'
  variable_set("site_owner_uid", $owner_uid);

  /**
   * TODO: error handling for configuring super admin and owner accounts?
 */

/*
  foreach($ret as $k => $v) {
    switch($k) {
      case 'success':
        if(!$v) {
          //error occurred -what should we do with this error?
        }
    }
  }
*/

  $edit_url = url($path = 'user/'.$owner_uid.'/edit', $options = array('fragment' => '', 'query' => '', 'absolute' => TRUE, 'alias' => FALSE, 'prefix' => ''));
  $edit_url = str_replace('?q=','', $edit_url);
  $edit_url = str_replace('admin',$node->shortname,$edit_url);
  $newsite_url = str_replace('user/'.$owner_uid.'/edit','', $edit_url);

  $variables = array(
  '!givenname' => $node->givenname,
  '!username' => $newusername,
  '!site' => $new_db['path'],
  '!site_name' => $node->title,
  '!password' => $newpass,
  '!uri' => $newsite_url,
  '!edit_uri' => $edit_url,
  '!current_user' => $current_user,
  );

  $params['subject'] = t("A LifeDesk has been created for you"); //subject
  $params['body'] = t("Dear !givenname,\n\nA LifeDesk '!site_name' has been created and is accessible at !uri\nYou are the administrator of this LifeDesk. You may login using the following username and password:\n\n  username: !username\n  password: !password\n\nYou may later change both the username and password in your account.\n\n- The LifeDesk Team", $variables); //mail body

  //only send mail when form submitted directly and not via the marketing page
  if(!$node->username) {
	drupal_mail('multisite_manager', 'direct', $node->mail, user_preferred_language($user), $params, $from);
  }

  $params['subject'] = t("LifeDesk '!site_name' has been created!",$variables);
  $params['body'] = t("Dear !current_user,\n\n You have created LifeDesk '!site_name' accessible at !uri\n\n- The LifeDesk Team", $variables);
  drupal_mail('multisite_manager', 'direct', $from, user_preferred_language($user), $params, $from);

  //after install_profile, because otherwise {cache} and {variable} don't exist yet
  variable_init(); //soak up anything from {variable}

  /*BEGIN THEFT*/
  //TODO: call profile tasks

  // Show profile finalization info.
  $function = $node->profile.'_profile_tasks';
  if (function_exists($function)) {
    // More steps required
    //PARANOIA: buggy set_active_db() makes us set this again, just for fun
  /*END THEFT*/

    $mid_cur_db = _multisite_manager_dbswitch($new_db);
    //BUG: $url here will probably mess things up if it's actually used
    $task = 'profile'; ///is passed by reference. we should foreach the tasks
    $profile_message = $function($task, _multisite_manager_node_url($node));
  }

  //PARANOIA: buggy set_active_db() makes us set this again, just for fun
  $mid_cur_db = _multisite_manager_dbswitch($new_db);

  ///TASK 'done'
  /*BEGIN THEFT (install.php)*/
  /* code ripped from install.php:install_tasks  */

  // Rebuild menu to get content type links registered by the profile,
  // and possibly any other menu items created through the tasks.
  menu_rebuild();
  actions_synchronize();
  // Store install profile for later use.
  variable_set('install_profile', $node->profile);
  variable_set('site_mail', $node->mail);
  variable_set('shortname', $node->shortname);
  variable_set('site_name', $node->title);
  variable_set('lifedesk_announcements', $site_message);
  variable_set('lifedesk_version', $site_version);

  /*END THEFT (install.php)*/

  if ($new_db['new'] && $new_db['prefix'] != $db_prefix) {
    ///OK, time to rename all the tables that were just created
    ///Is this hacky or what!?!?!

    ///PARANOIA.  We switch AGAIN to make ABSOLUTELY SURE we don't
    ///              go and rename the tables of the CURRENT DATABASE
    $mid_cur_db = _multisite_manager_dbswitch($new_db);

    //drupal_set_message('Renaming tables in the new database.');
    $result = _multisite_manager_tables_result($db_prefix);

    if ($cur_db['url'] != $mid_cur_db['url']) {
      ///This is a sanity check.  We can still rename the tables, but without the RE-SWITCH, we would have clobbered our CUR_DB
      drupal_set_message('Something has gone horribly wrong.  The database '. $mid_cur_db['url']  .' is NOT the new one.  Therefore, the database was switched mysteriously some time during installation.  Thus some features that were intended to be in your new database may have polluted your current database.','error');
    }

    ///Actually RENAME the TABLES
    while($table = @db_fetch_array($result)) {
      $table_name = array_pop($table);
      @db_query("ALTER TABLE %s RENAME TO %s%s", $table_name, $new_db['prefix'], substr($table_name,strlen($cur_db['prefix'])) );
    }

    $db_prefix = $cur_db['prefix'];
  }

  //execute flush_caches on site to ensure all is well. Only works with wildcard DNS or if hosts file entry already exists
  global $base_url;
  $url_parts = parse_url_domain($base_url);
  @do_get_request('http://' . $node->shortname . '.' . $url_parts[1] . '.' . $url_parts[2] . '/flush_caches');

  //get the Apache Solr hash and add to table
  $solr = db_result(db_query("SELECT value FROM variable WHERE name='apachesolr_site_hash'"));
  $solr = ($solr) ? unserialize($solr) : '';	

  /* SWITCH BACK TO OLD DB */
  _multisite_manager_dbswitch($cur_db);

  //remove cached versions of stuff for new site so as not to corrupt this site's page
  module_list(TRUE, FALSE);
  module_implements('nodeapi', FALSE, TRUE);
  node_get_types('return_nothing', FALSE, TRUE);

  /* DB QUERIES NOW ON MAIN */
  ///Restore $conf for current context
  $conf = $cur_conf;

  if (isset($profile_message)) {
    drupal_set_message($profile_message);
  }

  if (module_exists('drupal_sites')) {
    db_query("UPDATE {drupal_site} SET solr_hash='%s' WHERE shortname='%s'", $solr, $node->shortname);
  }

}

function parse_url_domain ($url) {
 $parsed = parse_url($url);
 $parts = explode('.',$parsed['host']);
 return $parts;
}

/**
 * Function to perform a http get
*/
function do_get_request($url) {
     $params = array('http' => array(
                  'method' => 'GET',
                  'content' => ''
               ));
     if ($optional_headers !== null) {
        $params['http']['header'] = $optional_headers;
     }
     $ctx = stream_context_create($params);
     $fp = @fopen($url, 'rb', false, $ctx);
     $response = @stream_get_contents($fp);
     return;
}

/**
 * Implementation of hook_update().
 */
function multisite_manager_update($node) {
  if (user_access('advanced database setup')) {
    db_query("UPDATE {drupal_site} SET
              link = '%s', shortname = '%s', run_cron = '%d', db_prefix = '%s', db_user = '%s', db_path = '%s'
              WHERE vid = %d",
	     $node->link,
	     $node->shortname,
	     $node->run_cron,
	     $node->db_prefix,
	     $node->db_user,
	     $node->db_path,
	     $node->vid);
    if ($node->db_pass) {
      db_query("UPDATE {drupal_site} SET db_pass = '%s' WHERE vid = %d", $node->db_pass, $node->vid);
    }
  }
  else {
    db_query("UPDATE {drupal_site} SET link = '%s', run_cron = '%s' WHERE vid = %d", $node->link, $node->run_cron, $node->vid);
  }
}

/*
 * returns a $result from a query of the tables for a certain db prefix
 */
function _multisite_manager_tables_result($prefix) {
  $result;
    /* Just to be safe, we escape all queries with @ so it's less likely
     * that a warning message will try to be written to the {session} db
     * while we're switched (and {session} in one use case is being deleted!!).
     */
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $result = @db_query("SHOW TABLES LIKE '%s%%'", str_replace('_','\_',$prefix));
      break;
    case 'pgsql':
      $result = @db_query("SELECT relname FROM pg_stat_user_tables WHERE relname LIKE '%s%%'", str_replace('_','\_',$prefix));
      break;
  }
  return $result;
}

/**
 * Implementation of hook_delete().
 */
function multisite_manager_delete($node) {
  /*
    before deleting database, make sure the list of show tables
    if prefix isn't "" --but even then, what if the 'new' ones
    all end up in the same database
  */
  /*
    If db_path has {shortname} in it, then a database is singularly related to that
    site, and we can just delete the whole thing.
  */
  if (strpos($node->db_path,'{shortname}') !== FALSE) {
    $database = $node->shortname;
    db_query('DROP DATABASE %s',$database);

    if (module_exists('drupal_sites')) {
      db_query("DELETE FROM {request_experts} WHERE url_requested='%s'",$node->shortname);
    }
  }
  elseif (strpos($node->db_prefix,'{shortname}') !== FALSE) {
    $new_db =_multisite_manager_dbobj($node);
    /* SWITCH TO NEW DB */
    if ($new_db['new']) {
      ///note: prefix is not changed here, and doesn't have to be.
      $cur_db = _multisite_manager_dbswitch($new_db);
    }
    /* DB QUERIES NOW ON NEW SITE DB */
    $result = _multisite_manager_tables_result($new_db['prefix']);

    while ($table = @db_fetch_array($result)) {
      $table_name = array_pop($table);
      drupal_set_message("Dropping table ".$table_name);
      @db_query("DROP TABLE %s", $table_name);
    }
    /* SWITCH BACK TO OLD DB */
    if ($new_db['new']) {
      _multisite_manager_dbswitch($cur_db);
    }
    /* DB QUERIES NOW ON MAIN */
  }

  ///Finally, delete from our own records
  db_query("DELETE FROM {drupal_site} WHERE vid = %d", $node->vid);

  global $user;
  $current_user = $user->givenname;

  $variables = array(
  '!site_name' => $node->title,
  '!current_user' => $current_user,
  );

  $recipient = variable_get('site_mail', 'lifedesk@eol.org');
  $params['subject'] = t("LifeDesk '!site_name' has been deleted!",$variables);
  $params['body'] = t("Dear !current_user,\n\nYou have deleted LifeDesk '!site_name' successfully!\n\n- The LifeDesk Team", $variables);
  drupal_mail('multisite_manager', 'direct', $recipient, user_preferred_language($user), $params, $recipient);
}

/**
 * For deletion of folders after subsite deletion. - Start
 * Usually we can't remove a directory using 'rmdir', if it is not empty.
 * This is a recursive function written for deleting a folder which is not empty.
 */
function multisite_manager_deltree($f) {
  if (is_dir($f)) {
    if (is_file("$f/.htaccess")) {
      chmod($f .'/.htaccess', 0777);
      unlink("$f/.htaccess");
    }
    foreach(glob($f.'/*') as $sf) {
      if (is_dir($sf) && !is_link($sf)) {
		multisite_manager_deltree($sf);
      } else {
		unlink($sf);
      }
    }
  }
  rmdir($f);
}
/* For deletion of folders after subsite deletion. - End */

/**
 * Implementation of hook_load().
 */
function multisite_manager_load($node) {
  $additions = db_fetch_object(db_query('SELECT shortname, profile, link, installed, run_cron, db_prefix, db_user, db_path, mail, givenname, surname FROM {drupal_site} WHERE vid = %d', $node->vid));
  return $additions;
}

/**
 * Gets the node url from the link
 *
 * @param object $node
 * @return object
 */
function _multisite_manager_node_url($node) {
  global $conf;
  if ($node->link) {
    $node->url = str_replace('{shortname}', 'http://' . $node->shortname, $node->link);
    $node->url = str_replace('{base_url}', $conf['_lifedesks_domain'], $node->url);
  } // end if node link

  return $node;
} // end function _multisite_manager_node_url()


function multisite_manager_theme() {
  return array('multisite_manager_sitelink' => array ('arguments'=>array('node')));
}

function theme_multisite_manager_sitelink($node) {
  return l($node->title .' '. t('Site'), $node->url);
}

/**
 * Implementation of hook_mail
 */
function multisite_manager_mail($key, &$message, $params) {

  switch($key) {
    case 'direct':
      $message['subject'] = $params['subject'];
      $message['body'][] = $params['body'];
    break;
  }
}